---
title: "Setting a nlrx object for the range expansion IBM"
author: "Maxime Dahirel"
date: "10/01/2020"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

## Introduction (WIP)

This is a basic script showing how to run an experimental design for my "range expansion" individual-based model written in NetLogo, using the R package `nlrx`. See the nlrx publication for details.

## How to

First, let's load the packages.

```{r packages}
library(nlrx)
library(arm)  ## used for the logit function
library(tidyverse)
```

Then we need to create an nlrx object. It embeds information about the NetLogo install we are going to use, and the model we are going to work with:

```{r object}
nl_object <- nl(nlversion = "6.1.0", nlpath = "C:/Program Files/NetLogo 6.1.0",
               modelpath = "D:/Maxime/Documents/POSTDOC INRA SOPHIA/IBM/range-expansion-ibm-pp-2019/range_expansion.nlogo", 
               jvmmem = 1024)
```

We then design the experiments. There are several ways to do it, see nlrx help and article. Especially for "distinct" designs, I prefer to set the parameters combinations I want in a table beforehand, so they are easy to change, and also easy to re-use during post-processing. Here is an example where we manipulate the Allee threshold, the low-density dispersal rate and the dispersal-density slope. K and fecundity do not vary in this example between treatments, but we still set them here rather than later, because it allows us to immediately calculate the Fisherian velocity for each treatment:

```{r treatment_table}
trt_grid=tibble(treatment=c("control","weak Allee effect (a = 0.95)","strong Allee effect (a = 20)",
                            "density-dependent dispersal",
                            "reduced connectedness"),
                start_allee_thres=c(0,0.95,20,0,0), #setting this to 1 =~ a doubling of dispersal from n=0 to K, seems realistic
                disp0_mean=c(0.2,0.2,0.2,0.2,0.1)
) %>% 
  mutate(fecundity=5, K=450) %>% 
  mutate(velocity_fisher=2*sqrt(
    log(fecundity)*(1 - 1 / K) * (1 - start_allee_thres / 1)*  ##fecundity term at N = 1 individual
                                  0.5*invlogit(logit(disp0_mean)+(1/K)*slope_disp_mean)) ##dispersal term
    )

nreplicates=50

duration=100
```
We also set the number of replicates and the duration of each run here, just so we have every variable we may want to change in the same place.

We then add the experimental details to our nlrx object:

``` {r nlrx_experiment_1}
nl_object@experiment <- experiment(
  expname="test",
  outpath="D:/Maxime/Documents/POSTDOC INRA SOPHIA/IBM/range-expansion-ibm-pp-2019/output",
  repetition = 1,
  tickmetrics = "true",
  idsetup = "setup",
  idgo="go",
  stopcond="not any? turtles",
  runtime=duration,
  evalticks= 1:duration,
  metrics=c("ticks"),
  metrics.patches = c("pxcor","N_predispersal","N_postdispersal","N_allele0","N_allele1"),
  constants=list(
    "trait_variation"= "\"reshuffled\"",   ###careful with the way string variable/csts must be entered
    #"K"=450,
    #"start_allee_thres"=5,
    "duration"=duration,
    "logit_disp0_sd"=0,
    #"disp0_mean"=0.2,
    "slope_disp_sd"=0
    #"slope_disp_mean"=0,
    #"fecundity"=1.2,
    ),
  
  variables=list( ###needs to be a nested list
    "start_allee_thres"=list(values=trt_grid$start_allee_thres),
    "slope_disp_mean"=list(values=trt_grid$slope_disp_mean),
    "disp0_mean"=list(values=trt_grid$disp0_mean),
    "fecundity"=list(values=trt_grid$fecundity),
    "K"=list(values=trt_grid$K)
  )
  
)
```

Add an experimental design to it (here, a "distinct" design where one row in our treatment table = one combination of parameters. compare and contrast with "fully factorial" design):

```{r set_design}
set.seed(42) ##we set.seed here to guarantee the seeds selected below are the same everytime
nl_object@simdesign<-simdesign_distinct(nl=nl_object,nseeds=nreplicates)
```

And we run all the simulation runs we asked for, and store the results in our nlrx object:
```{r run_simulation}
model_runs=run_nl_all(nl_object)
setsim(nl_object, "simoutput")<-model_runs
```

Now that it's done (it may have taken some time), if you explore the model_runs object, you will see that it's a tibble with one row = one run at one generation, with patch-level information stored as a list. We need to "unroll" or "unnest" it, to have our patch-level information (which is what we want) in a tidy format:

```{r get_output}
output_patches=unnest(model_runs,cols=c(metrics.patches)) %>% 
  left_join(trt_grid)%>% 
  mutate(replicateID=paste(K,treatment,`random-seed`))%>% 
  mutate(Location_full=paste(replicateID,pxcor,ticks))
```
(At the same time, we merged the resulting table with the initial treatment table, so we get back the "plain text treatment name" column, as well as the column with Fisher's velocities. we also added uniqueID column for replicate and for each replicate-patch-time combination, which will be useful for some cases of post-processing)

